// Code generated by ogen, DO NOT EDIT.

package ogent

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *CreateOrderReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateOrderReq) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("item_type_example_1")
		s.ItemTypeExample1.Encode(e)
	}
	{

		e.FieldStart("item_type_example_2")
		e.Int(s.ItemTypeExample2)
	}
	{

		e.FieldStart("item_type_example_3")
		s.ItemTypeExample3.Encode(e)
	}
}

var jsonFieldsNameOfCreateOrderReq = [3]string{
	0: "item_type_example_1",
	1: "item_type_example_2",
	2: "item_type_example_3",
}

// Decode decodes CreateOrderReq from json.
func (s *CreateOrderReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateOrderReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "item_type_example_1":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ItemTypeExample1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_type_example_1\"")
			}
		case "item_type_example_2":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ItemTypeExample2 = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_type_example_2\"")
			}
		case "item_type_example_3":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ItemTypeExample3.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_type_example_3\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateOrderReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateOrderReq) {
					name = jsonFieldsNameOfCreateOrderReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateOrderReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateOrderReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateOrderReqItemTypeExample1 as json.
func (s CreateOrderReqItemTypeExample1) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateOrderReqItemTypeExample1 from json.
func (s *CreateOrderReqItemTypeExample1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateOrderReqItemTypeExample1 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateOrderReqItemTypeExample1(v) {
	case CreateOrderReqItemTypeExample1PHYSICAL:
		*s = CreateOrderReqItemTypeExample1PHYSICAL
	case CreateOrderReqItemTypeExample1DIGITAL:
		*s = CreateOrderReqItemTypeExample1DIGITAL
	case CreateOrderReqItemTypeExample1SERVICE:
		*s = CreateOrderReqItemTypeExample1SERVICE
	default:
		*s = CreateOrderReqItemTypeExample1(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateOrderReqItemTypeExample1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateOrderReqItemTypeExample1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateOrderReqItemTypeExample3 as json.
func (s CreateOrderReqItemTypeExample3) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateOrderReqItemTypeExample3 from json.
func (s *CreateOrderReqItemTypeExample3) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateOrderReqItemTypeExample3 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateOrderReqItemTypeExample3(v) {
	case CreateOrderReqItemTypeExample3PHYSICAL:
		*s = CreateOrderReqItemTypeExample3PHYSICAL
	case CreateOrderReqItemTypeExample3DIGITAL:
		*s = CreateOrderReqItemTypeExample3DIGITAL
	case CreateOrderReqItemTypeExample3SERVICE:
		*s = CreateOrderReqItemTypeExample3SERVICE
	default:
		*s = CreateOrderReqItemTypeExample3(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateOrderReqItemTypeExample3) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateOrderReqItemTypeExample3) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ListOrderOKApplicationJSON as json.
func (s ListOrderOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []OrderList(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes ListOrderOKApplicationJSON from json.
func (s *ListOrderOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ListOrderOKApplicationJSON to nil")
	}
	var unwrapped []OrderList
	if err := func() error {
		unwrapped = make([]OrderList, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem OrderList
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ListOrderOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ListOrderOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ListOrderOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateOrderReqItemTypeExample1 as json.
func (o OptUpdateOrderReqItemTypeExample1) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateOrderReqItemTypeExample1 from json.
func (o *OptUpdateOrderReqItemTypeExample1) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateOrderReqItemTypeExample1 to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateOrderReqItemTypeExample1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateOrderReqItemTypeExample1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateOrderReqItemTypeExample3 as json.
func (o OptUpdateOrderReqItemTypeExample3) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateOrderReqItemTypeExample3 from json.
func (o *OptUpdateOrderReqItemTypeExample3) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateOrderReqItemTypeExample3 to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateOrderReqItemTypeExample3) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateOrderReqItemTypeExample3) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrderCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrderCreate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{

		e.FieldStart("item_type_example_1")
		s.ItemTypeExample1.Encode(e)
	}
	{

		e.FieldStart("item_type_example_2")
		e.Int(s.ItemTypeExample2)
	}
	{

		e.FieldStart("item_type_example_3")
		s.ItemTypeExample3.Encode(e)
	}
}

var jsonFieldsNameOfOrderCreate = [4]string{
	0: "id",
	1: "item_type_example_1",
	2: "item_type_example_2",
	3: "item_type_example_3",
}

// Decode decodes OrderCreate from json.
func (s *OrderCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "item_type_example_1":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ItemTypeExample1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_type_example_1\"")
			}
		case "item_type_example_2":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ItemTypeExample2 = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_type_example_2\"")
			}
		case "item_type_example_3":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.ItemTypeExample3.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_type_example_3\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrderCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrderCreate) {
					name = jsonFieldsNameOfOrderCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrderCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrderCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrderCreateItemTypeExample1 as json.
func (s OrderCreateItemTypeExample1) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrderCreateItemTypeExample1 from json.
func (s *OrderCreateItemTypeExample1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderCreateItemTypeExample1 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrderCreateItemTypeExample1(v) {
	case OrderCreateItemTypeExample1PHYSICAL:
		*s = OrderCreateItemTypeExample1PHYSICAL
	case OrderCreateItemTypeExample1DIGITAL:
		*s = OrderCreateItemTypeExample1DIGITAL
	case OrderCreateItemTypeExample1SERVICE:
		*s = OrderCreateItemTypeExample1SERVICE
	default:
		*s = OrderCreateItemTypeExample1(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OrderCreateItemTypeExample1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrderCreateItemTypeExample1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrderCreateItemTypeExample3 as json.
func (s OrderCreateItemTypeExample3) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrderCreateItemTypeExample3 from json.
func (s *OrderCreateItemTypeExample3) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderCreateItemTypeExample3 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrderCreateItemTypeExample3(v) {
	case OrderCreateItemTypeExample3PHYSICAL:
		*s = OrderCreateItemTypeExample3PHYSICAL
	case OrderCreateItemTypeExample3DIGITAL:
		*s = OrderCreateItemTypeExample3DIGITAL
	case OrderCreateItemTypeExample3SERVICE:
		*s = OrderCreateItemTypeExample3SERVICE
	default:
		*s = OrderCreateItemTypeExample3(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OrderCreateItemTypeExample3) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrderCreateItemTypeExample3) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrderList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrderList) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{

		e.FieldStart("item_type_example_1")
		s.ItemTypeExample1.Encode(e)
	}
	{

		e.FieldStart("item_type_example_2")
		e.Int(s.ItemTypeExample2)
	}
	{

		e.FieldStart("item_type_example_3")
		s.ItemTypeExample3.Encode(e)
	}
}

var jsonFieldsNameOfOrderList = [4]string{
	0: "id",
	1: "item_type_example_1",
	2: "item_type_example_2",
	3: "item_type_example_3",
}

// Decode decodes OrderList from json.
func (s *OrderList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "item_type_example_1":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ItemTypeExample1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_type_example_1\"")
			}
		case "item_type_example_2":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ItemTypeExample2 = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_type_example_2\"")
			}
		case "item_type_example_3":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.ItemTypeExample3.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_type_example_3\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrderList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrderList) {
					name = jsonFieldsNameOfOrderList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrderList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrderList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrderListItemTypeExample1 as json.
func (s OrderListItemTypeExample1) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrderListItemTypeExample1 from json.
func (s *OrderListItemTypeExample1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderListItemTypeExample1 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrderListItemTypeExample1(v) {
	case OrderListItemTypeExample1PHYSICAL:
		*s = OrderListItemTypeExample1PHYSICAL
	case OrderListItemTypeExample1DIGITAL:
		*s = OrderListItemTypeExample1DIGITAL
	case OrderListItemTypeExample1SERVICE:
		*s = OrderListItemTypeExample1SERVICE
	default:
		*s = OrderListItemTypeExample1(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OrderListItemTypeExample1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrderListItemTypeExample1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrderListItemTypeExample3 as json.
func (s OrderListItemTypeExample3) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrderListItemTypeExample3 from json.
func (s *OrderListItemTypeExample3) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderListItemTypeExample3 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrderListItemTypeExample3(v) {
	case OrderListItemTypeExample3PHYSICAL:
		*s = OrderListItemTypeExample3PHYSICAL
	case OrderListItemTypeExample3DIGITAL:
		*s = OrderListItemTypeExample3DIGITAL
	case OrderListItemTypeExample3SERVICE:
		*s = OrderListItemTypeExample3SERVICE
	default:
		*s = OrderListItemTypeExample3(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OrderListItemTypeExample3) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrderListItemTypeExample3) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrderRead) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrderRead) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{

		e.FieldStart("item_type_example_1")
		s.ItemTypeExample1.Encode(e)
	}
	{

		e.FieldStart("item_type_example_2")
		e.Int(s.ItemTypeExample2)
	}
	{

		e.FieldStart("item_type_example_3")
		s.ItemTypeExample3.Encode(e)
	}
}

var jsonFieldsNameOfOrderRead = [4]string{
	0: "id",
	1: "item_type_example_1",
	2: "item_type_example_2",
	3: "item_type_example_3",
}

// Decode decodes OrderRead from json.
func (s *OrderRead) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderRead to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "item_type_example_1":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ItemTypeExample1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_type_example_1\"")
			}
		case "item_type_example_2":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ItemTypeExample2 = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_type_example_2\"")
			}
		case "item_type_example_3":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.ItemTypeExample3.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_type_example_3\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrderRead")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrderRead) {
					name = jsonFieldsNameOfOrderRead[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrderRead) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrderRead) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrderReadItemTypeExample1 as json.
func (s OrderReadItemTypeExample1) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrderReadItemTypeExample1 from json.
func (s *OrderReadItemTypeExample1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderReadItemTypeExample1 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrderReadItemTypeExample1(v) {
	case OrderReadItemTypeExample1PHYSICAL:
		*s = OrderReadItemTypeExample1PHYSICAL
	case OrderReadItemTypeExample1DIGITAL:
		*s = OrderReadItemTypeExample1DIGITAL
	case OrderReadItemTypeExample1SERVICE:
		*s = OrderReadItemTypeExample1SERVICE
	default:
		*s = OrderReadItemTypeExample1(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OrderReadItemTypeExample1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrderReadItemTypeExample1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrderReadItemTypeExample3 as json.
func (s OrderReadItemTypeExample3) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrderReadItemTypeExample3 from json.
func (s *OrderReadItemTypeExample3) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderReadItemTypeExample3 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrderReadItemTypeExample3(v) {
	case OrderReadItemTypeExample3PHYSICAL:
		*s = OrderReadItemTypeExample3PHYSICAL
	case OrderReadItemTypeExample3DIGITAL:
		*s = OrderReadItemTypeExample3DIGITAL
	case OrderReadItemTypeExample3SERVICE:
		*s = OrderReadItemTypeExample3SERVICE
	default:
		*s = OrderReadItemTypeExample3(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OrderReadItemTypeExample3) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrderReadItemTypeExample3) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OrderUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OrderUpdate) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{

		e.FieldStart("item_type_example_1")
		s.ItemTypeExample1.Encode(e)
	}
	{

		e.FieldStart("item_type_example_2")
		e.Int(s.ItemTypeExample2)
	}
	{

		e.FieldStart("item_type_example_3")
		s.ItemTypeExample3.Encode(e)
	}
}

var jsonFieldsNameOfOrderUpdate = [4]string{
	0: "id",
	1: "item_type_example_1",
	2: "item_type_example_2",
	3: "item_type_example_3",
}

// Decode decodes OrderUpdate from json.
func (s *OrderUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "item_type_example_1":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ItemTypeExample1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_type_example_1\"")
			}
		case "item_type_example_2":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.ItemTypeExample2 = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_type_example_2\"")
			}
		case "item_type_example_3":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.ItemTypeExample3.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_type_example_3\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OrderUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOrderUpdate) {
					name = jsonFieldsNameOfOrderUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OrderUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrderUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrderUpdateItemTypeExample1 as json.
func (s OrderUpdateItemTypeExample1) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrderUpdateItemTypeExample1 from json.
func (s *OrderUpdateItemTypeExample1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderUpdateItemTypeExample1 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrderUpdateItemTypeExample1(v) {
	case OrderUpdateItemTypeExample1PHYSICAL:
		*s = OrderUpdateItemTypeExample1PHYSICAL
	case OrderUpdateItemTypeExample1DIGITAL:
		*s = OrderUpdateItemTypeExample1DIGITAL
	case OrderUpdateItemTypeExample1SERVICE:
		*s = OrderUpdateItemTypeExample1SERVICE
	default:
		*s = OrderUpdateItemTypeExample1(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OrderUpdateItemTypeExample1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrderUpdateItemTypeExample1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OrderUpdateItemTypeExample3 as json.
func (s OrderUpdateItemTypeExample3) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OrderUpdateItemTypeExample3 from json.
func (s *OrderUpdateItemTypeExample3) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OrderUpdateItemTypeExample3 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OrderUpdateItemTypeExample3(v) {
	case OrderUpdateItemTypeExample3PHYSICAL:
		*s = OrderUpdateItemTypeExample3PHYSICAL
	case OrderUpdateItemTypeExample3DIGITAL:
		*s = OrderUpdateItemTypeExample3DIGITAL
	case OrderUpdateItemTypeExample3SERVICE:
		*s = OrderUpdateItemTypeExample3SERVICE
	default:
		*s = OrderUpdateItemTypeExample3(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OrderUpdateItemTypeExample3) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OrderUpdateItemTypeExample3) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *R400) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *R400) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("code")
		e.Int(s.Code)
	}
	{

		e.FieldStart("status")
		e.Str(s.Status)
	}
	{

		if len(s.Errors) != 0 {
			e.FieldStart("errors")
			e.Raw(s.Errors)
		}
	}
}

var jsonFieldsNameOfR400 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R400 from json.
func (s *R400) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R400 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R400")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR400) {
					name = jsonFieldsNameOfR400[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *R400) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R400) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *R404) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *R404) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("code")
		e.Int(s.Code)
	}
	{

		e.FieldStart("status")
		e.Str(s.Status)
	}
	{

		if len(s.Errors) != 0 {
			e.FieldStart("errors")
			e.Raw(s.Errors)
		}
	}
}

var jsonFieldsNameOfR404 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R404 from json.
func (s *R404) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R404 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R404")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR404) {
					name = jsonFieldsNameOfR404[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *R404) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R404) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *R409) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *R409) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("code")
		e.Int(s.Code)
	}
	{

		e.FieldStart("status")
		e.Str(s.Status)
	}
	{

		if len(s.Errors) != 0 {
			e.FieldStart("errors")
			e.Raw(s.Errors)
		}
	}
}

var jsonFieldsNameOfR409 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R409 from json.
func (s *R409) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R409 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R409")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR409) {
					name = jsonFieldsNameOfR409[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *R409) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R409) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *R500) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *R500) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("code")
		e.Int(s.Code)
	}
	{

		e.FieldStart("status")
		e.Str(s.Status)
	}
	{

		if len(s.Errors) != 0 {
			e.FieldStart("errors")
			e.Raw(s.Errors)
		}
	}
}

var jsonFieldsNameOfR500 = [3]string{
	0: "code",
	1: "status",
	2: "errors",
}

// Decode decodes R500 from json.
func (s *R500) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R500 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Status = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "errors":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Errors = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R500")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfR500) {
					name = jsonFieldsNameOfR500[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *R500) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R500) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateOrderReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateOrderReq) encodeFields(e *jx.Encoder) {
	{
		if s.ItemTypeExample1.Set {
			e.FieldStart("item_type_example_1")
			s.ItemTypeExample1.Encode(e)
		}
	}
	{
		if s.ItemTypeExample2.Set {
			e.FieldStart("item_type_example_2")
			s.ItemTypeExample2.Encode(e)
		}
	}
	{
		if s.ItemTypeExample3.Set {
			e.FieldStart("item_type_example_3")
			s.ItemTypeExample3.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateOrderReq = [3]string{
	0: "item_type_example_1",
	1: "item_type_example_2",
	2: "item_type_example_3",
}

// Decode decodes UpdateOrderReq from json.
func (s *UpdateOrderReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateOrderReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "item_type_example_1":
			if err := func() error {
				s.ItemTypeExample1.Reset()
				if err := s.ItemTypeExample1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_type_example_1\"")
			}
		case "item_type_example_2":
			if err := func() error {
				s.ItemTypeExample2.Reset()
				if err := s.ItemTypeExample2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_type_example_2\"")
			}
		case "item_type_example_3":
			if err := func() error {
				s.ItemTypeExample3.Reset()
				if err := s.ItemTypeExample3.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_type_example_3\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateOrderReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateOrderReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateOrderReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateOrderReqItemTypeExample1 as json.
func (s UpdateOrderReqItemTypeExample1) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateOrderReqItemTypeExample1 from json.
func (s *UpdateOrderReqItemTypeExample1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateOrderReqItemTypeExample1 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateOrderReqItemTypeExample1(v) {
	case UpdateOrderReqItemTypeExample1PHYSICAL:
		*s = UpdateOrderReqItemTypeExample1PHYSICAL
	case UpdateOrderReqItemTypeExample1DIGITAL:
		*s = UpdateOrderReqItemTypeExample1DIGITAL
	case UpdateOrderReqItemTypeExample1SERVICE:
		*s = UpdateOrderReqItemTypeExample1SERVICE
	default:
		*s = UpdateOrderReqItemTypeExample1(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateOrderReqItemTypeExample1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateOrderReqItemTypeExample1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateOrderReqItemTypeExample3 as json.
func (s UpdateOrderReqItemTypeExample3) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateOrderReqItemTypeExample3 from json.
func (s *UpdateOrderReqItemTypeExample3) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateOrderReqItemTypeExample3 to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateOrderReqItemTypeExample3(v) {
	case UpdateOrderReqItemTypeExample3PHYSICAL:
		*s = UpdateOrderReqItemTypeExample3PHYSICAL
	case UpdateOrderReqItemTypeExample3DIGITAL:
		*s = UpdateOrderReqItemTypeExample3DIGITAL
	case UpdateOrderReqItemTypeExample3SERVICE:
		*s = UpdateOrderReqItemTypeExample3SERVICE
	default:
		*s = UpdateOrderReqItemTypeExample3(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateOrderReqItemTypeExample3) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateOrderReqItemTypeExample3) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
